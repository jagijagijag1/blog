[{"title":"Qrunch記事のHugo on GitHub Pages移行とHugoテーマ拡張","date":"","description":"","body":" Hugo on GitHub Pagesの構成  移行したときのつまづき  画像リンク修正     テーマHugo Future Imperfect Slimの拡張  cssの上書き ブログパーツの設置  拍手ボタン アクセスカウンタ Pixelaユーザページのsocal icon       閉鎖してしまうQrunchで書いた記事をGitHub Pagesに移行したのと，選んだHugoテーマを少し拡張したので，そのときにやったことを書き留め．\n このブログのHugoソースは→GitHub - jagijagijag1/blog at source このブログ用に拡張したテーマは→GitHub - jagijagijag1/hugo-future-imperfect-slim at add-pixela-social  Hugo on GitHub Pagesの構成  Qrunchが閉鎖するため移行先としてGitHub Pagesを選択  Qrunch以上に合いそうなサービスがなかったため   ブログはGitHubプロジェクト(not ユーザ)に紐づくGitHub Pagesを利用 (https://\u0026lt;user-name\u0026gt;.github.io/\u0026lt;repository-name\u0026gt;にホスト)  ブログ単品としてホストしたいので，リポジトリ名をblogにして作成 masterブランチのdocsディレクトリ配下をホストするよう設定   sourceブランチにてHugoファイルを管理 + sourceブランチへのプッシュで起動するGitHub Actionsを設定しmasterブランチにHugoの静的サイト生成結果をpush  name: build hugo site on source \u0026amp; deploy to master on: push: branches: - source jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.75.1\u0026#39; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: master publish_dir: ./docs destination_dir: ./docs 移行したときのつまづき  QrunchはMarkdownで記述可能であったため，Exportしてきた記事データの修正点は大きく下記2つ  ヘッダ情報の修正 (dateのフォーマットなどをやるだけ) 本文中の画像リンク (若干つまづいたので後述)    画像リンク修正  Hugo上での記事管理は下記のディレクトリ構造にした  ... ├── content | ├── posts | | ├── 20xx_xx_xx | | | ├── xxxxxxx.png | | | └── index.md | | ├── 20xx_xx_xx | | | ├── xxxxxxx.png | | | └── index.md | | | ...  またプロジェクトに紐づくGitHub Pagesを利用したため，Hugoの設定でbase urlを設定  baseURL = \u0026#34;http://jagijagijag1.github.io/blog/\u0026#34; publishDir = \u0026#34;docs\u0026#34; ...  上記設定の場合，画像リンクは下記の通り修正して解決  修正前: [image](https://s3.qrunch.io/xxxxxxx.png) 修正後: [image](/blog/posts/20xx_xx_xx/xxxxxxx.png)  [image](xxxxxxx.png)で指定すると，記事中では正常に画像表示されるが，記事一覧ページからだとリンクがおかしくなって画像表示されなかった      (ここにたどり着くまでどういうディレクトリ構造がいいかとか，base url変えた時にどう画像リンク指定するかがよくわからず四苦八苦した…)\nテーマHugo Future Imperfect Slimの拡張  選んだテーマを少し改善・拡張  cssの上書き  static/css/add-on.cssに記述した内容は，テーマのCSSを上書きしてくれる デフォルトだと文字間隔やコードブロックのフォントなどが少し気に入らなかったので下記のように修正  #site-sidebar ul, .stats ul li { text-transform: none; } .nav { text-transform: none; letter-spacing: 0.2em; } h1, h2, h3, h4, h5, h6 { text-transform: none; letter-spacing: 0.1em; } code { font-family: Monaco, Inconsolata, Consolas, monospace; } .count-container \u0026gt; .count { font-family: Monaco, Inconsolata, Consolas, monospace; } ブログパーツの設置  Hugo Future Imperfect Slimのリポジトリをforkして拡張  Hugoで下記コマンドでテーマ取得してconfig.tomlでテーマ指定+各パーツのパラメタ指定すれば利用可能 git submodule add -b add-pixela-social https://github.com/jagijagijag1/hugo-future-imperfect-slim.git themes/hugo-future-imperfect-slim    拍手ボタン  Qrunchにはあった拍手ボタンをこっちにも一応つけてみる  拍手ボタンにはApplause Buttonを利用   まず拍手ボタンを使うためのCSSとJSを読み込み  \u0026lt;head\u0026gt; ... {{ if .Site.Params.enableApplause }} \u0026lt;link href=\u0026#34;https://unpkg.com/applause-button/dist/applause-button.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/applause-button/dist/applause-button.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;/head\u0026gt;  次に，拍手ボタンを設置する部品を下記の通り作成  url属性に各記事ページのURL(Permlink)を設定することで，記事ごとに拍手数を保持できるようにする    {{ if .Site.Params.enableApplause }} \u0026lt;div\u0026gt; \u0026lt;applause-button color=\u0026#34;{{ .Site.Params.applauseButtonColor }}\u0026#34; url=\u0026#34;{{ .Permalink }}\u0026#34; multiclap=\u0026#34;true\u0026#34; style=\u0026#34;width: 55px; height: 55px; margin-right: 15px;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; {{ end }}  その後上記部品を各記事に表示するよう設定  ... \u0026lt;article class=\u0026#34;post\u0026#34;\u0026gt; {{ .Render \u0026#34;header\u0026#34; }} \u0026lt;div id=\u0026#34;socnet-share\u0026#34;\u0026gt; {{ partial \u0026#34;applause\u0026#34; . }} \u0026lt;!-- Add this line --\u0026gt; {{ partial \u0026#34;share-buttons\u0026#34; . }} \u0026lt;/div\u0026gt; ...  ただしApplause ButtonのCSSがブログテーマのCSSと競合しているので，下記を追加設定  具体的には，カテゴリの記事数の要素に与えられる.countと，拍手数の要素に与えられる.countが競合するので，拍手数の.count-container \u0026gt; .countのCSSに手を加える またapplause-buttonのcolor属性で指定した値は，.count-containerの親要素の.style-rootが持っているので，そこから無理やり継承する    .count-container { color: inherit !important; } .count-container \u0026gt; .count { float: none !important; color: inherit !important; } { \u0026#34;styles\u0026#34; : [ \u0026#34;css/applausebutton.css\u0026#34;, ...  上記が反映されたテーマをsubmoduleに入れ，ブログ本体の設定ファイルに以下を追記すれば各記事に拍手ボタンが表示される  [params] ... enableApplause = true applauseButtonColor = \u0026#34;firebrick\u0026#34; アクセスカウンタ  Hugo Future Imperfect Slimでサイドバーに，Qrunchでも使っていたPixelaグラフのアクセスを追加 サイドバー設定ファイルに以下を追記  iframeタグでも描画可能だが，テーマの色に合わせて強制で白背景にしたかったのでscriptタグを使って実現    ... {{ if .Site.Params.sidebar.pixelaAccessCounter }} \u0026lt;section id=\u0026#34;pixela_access_counter\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Blog PVs\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;div id=\u0026#34;svg-load-area\u0026#34; style=\u0026#34;border: 1px solid rgba(161, 161, 161, 0.3);\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-align:right;\u0026#34;\u0026gt;Powered by \u0026lt;a href=\u0026#34;https://pixe.la/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Pixela\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/tippy.js@3/dist/tippy.all.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function(){ $(\u0026#39;#svg-load-area\u0026#39;).load(\u0026#39;{{.Site.Params.sidebar.pixelaACGraphURL}}\u0026#39;, function(){ tippy(\u0026#39;.each-day\u0026#39;, { arrow: true }); }); }); \u0026lt;/script\u0026gt; {{ end }} ...  上記が反映されたテーマをsubmoduleに入れ，ブログ本体の設定ファイルに以下を追記すればサイドバーにグラフが表示される  ... [params.sidebar] pixelaAccessCounter = true pixelaACGraphURL = \u0026#34;https://pixe.la/v1/users/\u0026lt;user-id\u0026gt;/graphs/\u0026lt;graph-id\u0026gt;?mode=short\u0026#34; ... Pixelaユーザページのsocal icon  Hugo Future Imperfect SlimではサイドバーにTwitterなどのソーシャルアカウントへのリンクアイコンを設置可能 最近Pixelaにてユーザプロフィールページがリリースされたので自分のページへのリンクを追加してみた  Pixela にユーザープロフィールページができました！（v1.20.0 リリース） #pixela - えいのうにっき   social icon設定ファイルに下記を追記  ... {{ with .Site.Social.pixela }}\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;//pixe.la/{{.}}\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34; title=\u0026#34;Pixela\u0026#34; class=\u0026#34;fas fa-th\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;{{ end }}  上記が反映されたテーマをsubmoduleに入れ，ブログ本体の設定ファイルに以下を追記すればサイドバーにソーシャルアイコンが表示される  [social] ... pixela = \u0026#34;@\u0026lt;pixela-user-id\u0026gt;\u0026#34; ","ref":"/blog/posts/2020_10_25/"},{"title":"bulmaのcolumnを使った際にモバイル表示するとサイドに余白が出る場合の対処","date":"","description":"","body":"症状  下記の緑領域のように，classにcolumn指定した要素のpaddingが，モバイル表示した際に画面外に表示されてしまう  解決  下記bodyへのcss設定を入れる  ... \u0026lt;style lang=\u0026#34;scss\u0026#34;\u0026gt; ... body { overflow-x: hidden; } ... \u0026lt;/style\u0026gt; 参考  下記で議論されてる  class \u0026ldquo;columns\u0026rdquo; too wide on mobile · Issue #449 · jgthms/bulma · GitHub    ","ref":"/blog/posts/2020_04_30/"},{"title":"リングフィットアドベンチャーの運動ログをサーバーレスでPixelaに記録する","date":"","description":"","body":"作ったもの  リングフィットアドベンチャーの運動ログ(活動時間，消費カロリー，走行距離)をPixelaに記録して草化する機能をサーバーレスで開発 Switch上でスクショを撮りTwitter投稿すると，画像取得・解析してPixelaのグラフに記録  結果  最近のサボりが可視化された💪   トリガになるツイートは↓な感じ  #リングフィットアドベンチャー #RingFitAdventure #NintendoSwitch pic.twitter.com/ZnoWCO30No\n\u0026mdash; JagiJagiJagi (@jagijagijag1) January 25, 2020 \r制約  下記画像のような日毎の運動ログ画面から活動時間，消費カロリー, 走行距離を抽出することのみが対象  その他画面のスクショや個別運動ログは対象外    TwitterのツイートページのHTMLを解析するため，ページの仕様が変わると実行不可 まれにAWS Rekognitionが0をoと判定し，Pixelaへの記録時にエラーが発生する (数値しかありえないので無理やり補正できなくもないが未実施)  全体方針  リングフィットの記録はAPIで取得したりはできないので，スクショから情報引っこ抜くしかない(と思われる) 頑張り度と継続度がみたいので，ライフログを色々記録しているPixelaで可視化  Switchスクショ取得方針  Switchのスクショを自動でクラウドストレージに持っていく手段がない  SDカードを経由する方法だとバッチ的になる \u0026amp; 怠惰なので続かなそう…   Swithcでスクショ投稿はできるので，Twitterにあげてそこから自動でごにょごにょする方針に → サービス連携として手軽なIFTTTを使って特定のハッシュタグ付きTwitter投稿を自動取得 -\u0026gt; 後続処理のAPIを叩くレシピは後述  スクショからの情報抽出   GarminストレスのときはAWS Rekognitionを使ったが，日本語テキスト検出未対応\n cf. Garmin connectのストレス測定結果をPixela + Serverlessで草化 - jagijagijag1\u0026rsquo;s tech blog    そのためGoogle CloudのVision APIを利用する方針で検討，デモ試して行けそう\n   と思ったが，日付と活動量の数値だけ取るならRekognitionでもできそうなので，慣れているAWSを使う方針に，こっちでも行けそう (↓だけ見ると日本語も取れてるように見えるけど日本語部分は英数字の羅列として結果が返ってくる)\n\r  その他つまづきなど  IFTTTで取得できるリンクは画像自体のリンクでなく画像ツイートページのリンクなので，IFTTTからAPI(Lambda)に渡されるリンクから画像リンクを探し出すはめに…  Integromatだとツイートの画像リンク取得までできるっぽい   日付について，スクショからは月と日(mm/dd)しか取れないため，とりあえず処理実行時の年を付与し，それが未来の日付の場合は年を1年前の日付で記録するよう実装  e.g. 01/23 -\u0026gt; 20200123, 10/23 -\u0026gt; 20191023 (20201023は未来なので)   ツイートページから画像URLを引っこ抜く実装にしたことにより，複数画像のまとめて投稿にも対応可能に  ただし画像が多いとIFTTTのWebhookの待ち時間を超過するっぽく，IFTTT上は失敗扱いに (Lambdaは正常終了しPixelaにも記録される)    実装内容  コードは→jagijagijag1/ringfit2pixela · GitHub  環境  Go 1.13.6 Serverless Framework 1.61.3  Lambda function (画像取得・情報抽出・グラフ記録)  IFTTTのレシピ作成時に，Lambda関数を実行するAPI GatewayのエンドポイントURLが必要になるため先にこちら側を実装 Serverless Frameworkを用いてGoで実装したLambda関数 + API Gatewayをデプロイ 詳細はコード参照，概要は以下  IFTTTから送られてきたツイートのURLを入力に，画像URLを引っこ抜き，Rekognitionでのテキスト検知結果を受け，Pixelaに記録する  入力のURLをHTML解析して画像URLを抽出し，画像URLから画像データを取得し，Rekognitionにわたす 記録したい情報は，その情報があるであろう座標をあらかじめ与えておき，Rekognitionの結果のうち想定座標に対して最近傍のテキストを利用      IFTTT: Twitter → Webhook (API Gateway)  IFTTで下記レシピで作成する  ここではハッシュタグ #RingFitAdventureのあるツイートを対象に (任意のハッシュタグでOK) URL欄にはデプロイしたAPI Gatewayのエンドポイント(=make deployした際の出力のServiceEndpoint)に/ringfit2pixelaなどのパスをくっつけたURLを設定   下記レシピ作成後，Nintendo Switch内でTwitter投稿すればPixelaに記録されるはず  ただしIFTTTの実行が結構遅い (10〜20分くらいかかる)    \n","ref":"/blog/posts/2020_01_26/"},{"title":"Cloue Run + Puppeteer + Cloud Schedulebr でサーバーレスなクロールを定期実行する","date":"","description":"","body":"つくるもの  手軽に定期実行するクローラを作りたかった 題材として，あすけん のスコア(健康度)をPixelaに転記する処理を1日1回実行する自動化システムをつくる  転記の結果 つまづきメモ AWS LambdaをやめてGCP Cloud Runを選択  まず最初に，ローカルでPuppeteerを用いてaskenをcrawl → pixelaへ記録する機能を開発  asken2pixela/local GitHub   これをベースにPuppeterr on Lambdaでサーバーレスな定期クロールを実現するつもりだった  ref: Puppeteer on AWS LambdaをTypescriptからサクッと使う(2019年9月版) - ADliveテックブログ   が，Page.$$eval()の返り値が通常のPuppeteerとLambda用のPuppeteerとで違った…  通常のPuppeteer: Array\u0026lt;Element\u0026gt;が返ってきた Lambda用のPuppeteer: Array\u0026lt;ElementHandle\u0026gt;が返ってきた   このギャップを埋める修正が面倒なので，ローカルで動いているコード(=普通のPuppeteer)をサーバーレスで動かせばいいのでは? → Cloud Runがある！  Cloud Run: リクエストに応じてコンテナを起動・処理するサーバーレスなGCPのサービス    Puppeteerのevalなどで渡す関数内処理のロギング  PuppeteerのPage.$$eval()などの引数で渡す関数内でconsole.log()でログを取りたかったが，そのまま書いてもスコープが変わるためコンソール出力されない これに対し，consleイベントをdispatchすることができたため，Pageオブジェクトに対して下記処理を実施し，Page.$$eval()内のログ出力に成功  ref: javascript - Puppeteer log inside page.evaluate - Stack Overflow    const browser = await puppeteer.launch(); const page = await browser.newPage(); page.on(\u0026#39;console\u0026#39;, consoleMessageObject =\u0026gt; function (consoleMessageObject) { if (consoleMessageObject.type() !== \u0026#39;warning\u0026#39;) { console.debug(consoleMessageObject.text()) } }); await page.goto(\u0026#39;https://google.com\u0026#39;); const result = await page.evaluate(() =\u0026gt; { console.log(\u0026#39;Browser scope.\u0026#39;); return \u0026#39;Normal scope.\u0026#39;; }); console.log(result) その他細かいところ  DockerfileでAZを指定しないと日付がUTCで処理される  Cloud SchedulerがJST 11/23 1:00に起動しても，UTC 11/22 16:00で処理が進む   TypeScriptアプリをDockerに乗せるときの作法を知らない…  とりあえず今回はローカルでトランスパイルして，生成されたindex.jsだけをDockerにのせた    開発環境 GCPアカウント/プロジェクトは作成済みとする．\n$ gcloud version Google Cloud SDK 271.0.0 beta 2019.05.17 bq 2.0.50 core 2019.11.08 gsutil 4.46 $ yarn --version 1.19.1 $ tsc --version Version 3.6.4 開発詳細  作ったものはGitHub - jagijagijag1/asken2pixela  1. Puppeteer on Cloud Runの動作確認 Expressでリクエストを受けてPuppeteerを実行する設定・プログラムを準備  package.json  { \u0026#34;name\u0026#34;: \u0026#34;asken2pixela-cloudrun\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;asken2pixela on GCP Cloud Run\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;tsc -p . \u0026amp;\u0026amp; node .\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;tsc -p .\u0026#34;, \u0026#34;server\u0026#34;: \u0026#34;node index.js\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;express\u0026#34;: \u0026#34;^4.17.1\u0026#34;, \u0026#34;puppeteer\u0026#34;: \u0026#34;^2.0.0\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/express\u0026#34;: \u0026#34;^4.17.2\u0026#34;, \u0026#34;@types/puppeteer\u0026#34;: \u0026#34;^1.20.2\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^3.7.2\u0026#34; } }  index.ts  import puppeteer from \u0026#39;puppeteer\u0026#39; import express from \u0026#34;express\u0026#34;; const app = express(); const askenUrl = \u0026#39;http://asken.jp/login\u0026#39;; // put your own target  app.get(\u0026#39;/\u0026#39;, async (req, res) =\u0026gt; { console.log(\u0026#39;Request received\u0026#39;); const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(askenUrl); const title = await page.title(); await page.close(); // response message with web page title  res.send(`Access to ${title}`); }); const port = process.env.PORT || 8080; app.listen(port, () =\u0026gt; { console.log(\u0026#39;Listening on port\u0026#39;, port); });  Dockerfile  # Use the official lightweight Node.js 10 image.\r# https://hub.docker.com/_/node\rFROM node:10-slim\r# Create and change to the app directory.\rWORKDIR /usr/src/app\r# Copy application dependency manifests to the container image.\rCOPY package.json yarn.lock ./\r# Install latest chrome dev package and fonts to support major charsets (Chinese, Japanese, Arabic, Hebrew, Thai and a few others)\rRUN wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add - \\\r\u0026amp;\u0026amp; sh -c 'echo \u0026quot;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main\u0026quot; \u0026gt;\u0026gt; /etc/apt/sources.list.d/google.list' \\\r\u0026amp;\u0026amp; apt-get update \\\r\u0026amp;\u0026amp; apt-get install -y google-chrome-unstable fonts-ipafont-gothic fonts-wqy-zenhei fonts-thai-tlwg fonts-kacst fonts-freefont-ttf \\\r--no-install-recommends \\\r\u0026amp;\u0026amp; rm -rf /var/lib/apt/lists/*\r# Install puppeteer so it's available in the container.\rRUN yarn add puppeteer \\\r# Add user so we don't need --no-sandbox.\r# same layer as npm install to keep re-chowned files from using up several hundred MBs more space\r\u0026amp;\u0026amp; groupadd -r pptruser \u0026amp;\u0026amp; useradd -r -g pptruser -G audio,video pptruser \\\r\u0026amp;\u0026amp; mkdir -p /home/pptruser/Downloads \\\r\u0026amp;\u0026amp; chown -R pptruser:pptruser /home/pptruser \\\r\u0026amp;\u0026amp; chown -R pptruser:pptruser ./node_modules\r# Set environment variables\rENV TZ Asia/Tokyo\rENV PORT 8080\r# Install production dependencies.\rRUN yarn install --production\r# Copy local code to the container image.\rCOPY index.js ./\rRUN chown -R pptruser:pptruser ./*\r# Run everything after as non-privileged user.\rUSER pptruser\r# Run the web service on container startup.\rEXPOSE 8080\rCMD [ \u0026quot;yarn\u0026quot;, \u0026quot;run\u0026quot;, \u0026quot;server\u0026quot; ]\r DockerでPuppeteerを動かすときの参考: puppeteer/troubleshooting.md at master GoogleChrome/puppeteer GitHub  用意したものをデプロイ $ yarn install # build TypeScript code $ yarn build # push Dockerfile to GCP $ gcloud builds submit --tag gcr.io/\u0026lt;your-projectr-id\u0026gt;/\u0026lt;your-image-name\u0026gt; # create Cloud Run (Puppeteerを動かすため，メモリサイズを512Mに設定) $ cloud beta run deploy \u0026lt;your-cloudrun-name\u0026gt; --image gcr.io//\u0026lt;your-projectr-id\u0026gt;/\u0026lt;your-image-name\u0026gt; --platform managed --region asia-northeast1 --allow-unauthenticated --memory 512Mi  最後にCloud Runのエンドポイントが表示されるのでメモしておく  当該URLにブラウザアクセス or curlで動作確認可能    2. Cloud Schedulerの作成・動作確認 毎日AM1:00に上記Cloud Runを実行するCloud Schedulerジョブを作成しテスト実行 # create Cloud Scheduler job $ gcloud scheduler jobs create http \u0026lt;your-job-name\u0026gt; --schedule \u0026#34;00 01 * * *\u0026#34; --time-zone \u0026#34;Asia/Tokyo\u0026#34; --http-method=GET --uri=\u0026#34;\u0026lt;your-cloudrun-endpoint\u0026gt;\u0026#34; --headers=Content-Type=application/json # test run $ gcloud scheduler jobs run \u0026lt;your-job-name\u0026gt;  その後Cloud Run, Cloud Schedulerのログを確認し動作確認  3. Puppeteer処理の実装 利用パッケージ追加 $ yarn add axios メイン処理 長いので下記参照 (puppeterでcrawlして取得した結果をaxiosでpostしてるだけ) asken2pixela/index.ts GitHub\nDockerfileに環境変数設定を追加 ...\r# Set environment variables\rENV TZ Asia/Tokyo\rENV PORT 8080\rENV ASKEN_URL http://asken.jp/login\rENV ASKEN_EMAIL \u0026lt;your-login-email-address\rENV ASKEN_PASS \u0026lt;your-login-password\u0026gt;\rENV PIXELA_USER \u0026lt;your-pixela-user-id\rENV PIXELA__GRAPH \u0026lt;your-pixela-graph-id\rENV PIXELA_TOKEN \u0026lt;your-pixela-token\u0026gt;\r...\r再デプロイ # build \u0026amp; push Dockerfile to GCP $ yarn build \u0026amp;\u0026amp; gcloud builds submit --tag gcr.io/\u0026lt;your-projectr-id\u0026gt;/\u0026lt;your-image-name\u0026gt; # create Cloud Run (Puppeteerを動かすため，メモリサイズを512Mに設定) $ cloud beta run deploy \u0026lt;your-cloudrun-name\u0026gt; --image gcr.io//\u0026lt;your-projectr-id\u0026gt;/\u0026lt;your-image-name\u0026gt; --platform managed --region asia-northeast1 --allow-unauthenticated --memory 512Mi 完成！\n","ref":"/blog/posts/2019_11_23/"},{"title":"Boostnoteの動作が重いときの一解決事例","date":"","description":"","body":"結論  \u0026ldquo;Preference\u0026rdquo; → \u0026ldquo;Boostnoteについて\u0026rdquo; → \u0026ldquo;解析\u0026quot;でBoostnote の機能向上のための解析機能を有効にするをオフにすると解決するかも  症状  Boostnote上で頻繁にカーソル移動・文字入力などの動作が重くなる (キー入力の反映が遅延する) CPU使用率を見てみると，不定期にBoostnoteのCPU使用率が異常上昇していた  原因調査  Developer Toolを開くと，AWS CognitoへのPOSTメソッドの失敗が大量にあらわれていた 調べると↓とほぼ同様の症状だが，ここでは処理が重いという言及もなし  Amazon Cognito Indentity status 400 Issue #1905 BoostIO/Boostnote GitHub     Cognitoへのアクセスは使用状況レポートの収集のためのようで，上記Issueでは無視するかレポート機能をオフにするかとのこと 自分のケースではネットワーク接続が無い状況でBoostnoteを使ったときにこの症状が発生していた  解決  実際に\u0026quot;Preference\u0026rdquo; → \u0026ldquo;Boostnoteについて\u0026rdquo; → \u0026ldquo;解析\u0026quot;でBoostnote の機能向上のための解析機能を有効にするをオフにしてみたところ，動作が重くなる事象がなくなり，CPU使用率も上がらなくなった  ","ref":"/blog/posts/2019_10_05/"},{"title":"QrunchブログのサイドモジュールにPixelaグラフを表示する","date":"","description":"","body":" 先日Qrunchの大幅アップデートにより，ブログのカスタマイズ性が上がった  任意のHTML・JSスクリプトが挿入可能に    【お知らせ】正式リリース前最後の大幅アップデートを行います！（8月下旬予定）\n ということで，↓で紹介されているはてなブログへのPixelaグラフ埋め込みをQrunchでもできるはず!  はてなブログに Pixela グラフを埋め込んで、さらにツールチップを表示させる方法\n完成図  表示ごとにincrementされるグラフで簡易PVに 過去に作ったストレス草化で，ストレスを感じつつも生存してる報告  手順  a-knowさんのブログ見れば問題ないけど，一応QrunchのUI上でどこを設定するかメモ (指定するコードも元記事のまま) 以下，[ユーザーメニュー]→[デザインカスタマイズ] or ダッシュボード内[デザイン]で表示されるブログのデザイン設定画面で作業  サイドモジュール追加 (グラフ表示領域設定)  [サイドモジュール]にて[モジュールを追加する] [モジュールタイプ]で[カスタム]を選択 [モジュールタイトル]は任意，[コンテンツ（カスタムHTML）]に下記コード(a-knowさんブログまま)を入力し，[追加する]  \u0026lt;div id=\u0026#34;svg-load-area\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-align:right;\u0026#34;\u0026gt;Powered by \u0026lt;a href=\u0026#34;https://pixe.la/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Pixela\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt; ヘッダ下 or フッタ上にscriptタグ追加 (表示するグラフの設定)  [カスタムHTML]にて[ヘッダー下] or [フッター上]を選択  ヘッダ下 or フッタ上へのコード指定はPRO機能だが，今の所ベータ期間で誰でも無料でPRO機能を有効化できる  https://qrunch.net/pro     表示された入力エリアに下記コード(a-knowさんブログまま)を入力し，[適用] (グラフURLは表示したいグラフを指定)  \u0026lt;script src=\u0026#34;https://unpkg.com/tippy.js@3/dist/tippy.all.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function(){ $(\u0026#39;#svg-load-area\u0026#39;).load(\u0026#39;https://pixe.la/v1/users/a-know-blog/graphs/page-views?mode=short\u0026#39;, function(){ tippy(\u0026#39;.each-day\u0026#39;, { arrow: true }); }); }); \u0026lt;/script\u0026gt; ","ref":"/blog/posts/2019_09_03/"},{"title":"サーバーレスで定期的にDropbox内のファイルをS3に転送する","date":"","description":"","body":"つくったもの  定期実行でDropboxの特定フォルダ下ファイルをS3へ転送する機能 具体的には，CloudWatch Eventで定期起動し下記を実行するLambda関数を開発  Dropbox APIを叩いて特定フォルダ配下の全ファイルを取得 当該ファイルをダウンロードし，S3の特定バケットに保存 バケット保存が成功した場合，Dropbox側のオリジナルファイルを削除    経緯  以前S3に入ってきた画像を解析してPixelaに記録するLamba関数を開発  Garmin connectのストレス測定結果をPixela + Serverlessで草化 - qrunch.net   この際，iPhoneのスクリーンショットをS3へ送る手段を下記のように構築  IFTTTでiOSのスクリーンショットをDropboxに入れ，ZapierでDropboxからS3にコピーするようにして前に作ったストレス草化Lambdaとシームレスに連携するようにした．ちょっと経由しすぎな気もするけどひとまず…\n\u0026mdash; JagiJagiJagi (@jagijagijag1) November 8, 2018 \r しかしながら，これだけのためにZapierに課金するのも辛いので，イベント駆動を妥協して定期実行でDropbox→S3転送機能を実現してみた これにより，Zapierを経由せず，iPhoneからPixelaをシームレスに結合  環境  MacOS Mojave Go 1.11.5 Serverless Framework 1.38.0  ライブラリ選択  DropboxのGoライブラリは以下の2つを発見  GitHub - dropbox/dropbox-sdk-go-unofficial: An UNOFFICIAL Dropbox v2 API SDK for Go GitHub - tj/go-dropbox: Dropbox v2 client for Go.   前者の方が，非公式といいつつ一応Dropboxプロジェクト配下にあったのでこちらを選択 go get github.com/dropbox/dropbox-sdk-go-unofficial/dropbox  前準備  新規Dropboxアプリを登録  https://www.dropbox.com/developers/apps   作成後，SettingsタブのOAuth 2 - Generated access tokenで\u0026quot;Generate\u0026quot;すると，(テスト向け)トークンを取得可能  開発詳細 先につまづきメモ  Dropbox APIでファイル一覧を取得した際の返り値が[]IsMetadataで，ファイル(FileMetadata)として操作できず  Goの型アサーションでFileMetadataとして処理が可能に 詳細はこちら   Dropboxから取得したファイルコンテンツをS3にわたすため，下記変換手順を踏む必要あり  正直なところGoのio周りやDropboxのDwonload/AWSのReadSeekCloserの仕様を理解していないので，とりあえず[]byteらしきところを引っこ抜いて渡したらうまくいった状態    // download from dropbox dlArg := files.NewDownloadArg(fpath) res, content, err := dbx.Download(dlArg) // extract file content as []byte blob, _ := ioutil.ReadAll(content) // []byte -\u0026gt; Reader f := bytes.NewReader(blob) // Reader -\u0026gt; aws.ReadSeekCloser rs := aws.ReadSeekCloser(f) // S3 PutObject requires aws.ReadSeekCloser as its input body input := \u0026amp;s3.PutObjectInput{ Body: rs, Bucket: aws.String(bucketName), Key: aws.String(fileName), } 開発の初期設定  作ったものはGitHub $GOHOME/src配下の任意フォルダで作業  $ sls create -t aws-go-dep -p \u0026lt;project-name\u0026gt;  生成されたhelloとworldの2つの関数は不要なので削除 dropbox2s3ディレクトリとmain.goを作成 Makefile修正  .PHONY: build clean deploy\rbuild:\rdep ensure -v\renv GOOS=linux go build -ldflags=\u0026quot;-s -w\u0026quot; -o bin/dropbox2s3 dropbox2s3/main.go\rclean:\rrm -rf ./bin ./vendor Gopkg.lock\rdeploy: clean build\rsls deploy --verbose\r serverless.yml修正  service: dropbox2s3-periodic frameworkVersion: \u0026#34;\u0026gt;=1.28.0 \u0026lt;2.0.0\u0026#34; provider: name: aws runtime: go1.x region: ap-northeast-1 iamRoleStatements: - Effect: \u0026#34;Allow\u0026#34; Action: - \u0026#34;s3:ListBucket\u0026#34; Resource: \u0026#34;*\u0026#34; - Effect: \u0026#34;Allow\u0026#34; Action: - \u0026#34;s3:PutObject\u0026#34; Resource: \u0026#34;*\u0026#34; package: exclude: - ./** include: - ./bin/** functions: dropbox2s3: handler: bin/dropbox2s3 events: - schedule: cron(0 16 * * ? *) environment: TZ: Asia/Tokyo DROPBOX_TOKEN: \u0026lt;your-api-token\u0026gt; IMG_FOLDER_PATH: \u0026lt;target-project-id\u0026gt;  BUCKET_NAME: \u0026lt;your-bucket\u0026gt; timeout: 60 main関数修正  冒頭の処理をナイーブに実装  package main import ( \u0026#34;bytes\u0026#34; \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws/session\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/service/s3\u0026#34; \u0026#34;github.com/aws/aws-lambda-go/lambda\u0026#34; \u0026#34;github.com/dropbox/dropbox-sdk-go-unofficial/dropbox\u0026#34; \u0026#34;github.com/dropbox/dropbox-sdk-go-unofficial/dropbox/files\u0026#34; ) // Handler is our lambda handler invoked by the `lambda.Start` function call func Handler(ctx context.Context) error { // extract env var \tdropboxToken := os.Getenv(\u0026#34;DROPBOX_TOKEN\u0026#34;) imgFolderPath := os.Getenv(\u0026#34;IMG_FOLDER_PATH\u0026#34;) bucketName := os.Getenv(\u0026#34;BUCKET_NAME\u0026#34;) // tansport image from dropbox to s3 \ttransport(dropboxToken, imgFolderPath, bucketName) return nil } func transport(dropboxToken, imgFolderPath, bucketName string) { // dropbox setting \tconfig := dropbox.Config{ Token: dropboxToken, } dbx := files.New(config) // get info under the imgFolderPath folder \targ := files.NewListFolderArg(imgFolderPath) resp, err := dbx.ListFolder(arg) if err != nil { fmt.Println(\u0026#34;err in accesing dropbox folder\u0026#34;) fmt.Println(err) return } // for each file/folder \tfor _, e := range resp.Entries { // use type annotation to cast e (IsMetadata) to file (FileMetadata) \tf, ok := e.(*files.FileMetadata) if ok { // if e is file, download content \tfmt.Println(\u0026#34;find file \u0026#34;, f.Name) fpath := f.Metadata.PathLower dlArg := files.NewDownloadArg(fpath) res, content, err := dbx.Download(dlArg) if err != nil { fmt.Println(\u0026#34;err in downloading file\u0026#34;) fmt.Println(err) return } // and then put it to S3 \terr = putToS3(bucketName, res.Metadata.Name, content) if err == nil { // if successed, remove transported file on dropbox \tdeleteFromDropbox(dbx, fpath) } } } } func putToS3(bucketName, fileName string, content io.ReadCloser) error { // create s3 client \tsess := session.Must(session.NewSession(\u0026amp;aws.Config{ Region: aws.String(\u0026#34;ap-northeast-1\u0026#34;), })) svc := s3.New(sess) // create put-object input \tblob, _ := ioutil.ReadAll(content) f := bytes.NewReader(blob) rs := aws.ReadSeekCloser(f) input := \u0026amp;s3.PutObjectInput{ Body: rs, Bucket: aws.String(bucketName), Key: aws.String(fileName), } // put contet to s3 \t_, err := svc.PutObject(input) if err != nil { fmt.Println(\u0026#34;err in putting object\u0026#34;) fmt.Println(err) return err } fmt.Println(\u0026#34;put object \u0026#34;, fileName, \u0026#34; to \u0026#34;, bucketName) return nil } func deleteFromDropbox(dbx files.Client, filepath string) { delArg := files.NewDeleteArg(filepath) _, err := dbx.Delete(delArg) if err != nil { fmt.Println(\u0026#34;err in downloading file\u0026#34;) fmt.Println(err) return } } func main() { lambda.Start(Handler) } デプロイ  以下でデプロイ  make deploy = make + sls deploy    $ cd \u0026lt;project-name\u0026gt; $ make deploy ","ref":"/blog/posts/2019_03_02/"},{"title":"Cisco AnyConnectで再接続が数十秒ごとに繰り返される場合の対処","date":"","description":"","body":"環境  Windows 10 Pro 1803 Cisco AnyConnect Secure Mobility Client 4.6.011  症状  Cisco AnyConnectにてVPN接続した際に，認証・接続は成功するが，その後再接続(ログではReconnecting)を数秒〜数十秒おきに繰り返し続ける  解決 2019/01/24 追記\n  バージョン4.6.02074で修正済み\n https://community.cisco.com/t5/vpn-and-anyconnect/anyconnect-reconnects-with-hyper-v-adapter/m-p/3695961/highlight/true#M146261    アップデートできない場合の暫定対応策は以下\n Windows 10 ProのHyper-V機能を無効にする  ref. Windows 10 Hyper-Vを有効/無効にする方法 - 備忘録   Dockerをインストールした場合，Docker自体をアンインストールしていてもHyper-Vが有効になっている可能性あり TODO: Hyper-V(おそらく仮想スイッチ)とAnyConnectを共存させる方法は不明    ","ref":"/blog/posts/2019_01_22/"},{"title":"「あとで読む」をPixelaで可視化","date":"","description":"","body":"tl;dr なんでも草化できるWebサービスPixelaの利用についてつぶやいたところ，作者のa-knowさんから下記ツイートをいただきました！\nうおお……これはまた新しい活躍方法…！！ぜひブログなどにしていただきたいっ！ https://t.co/Cz5zrPVG0Q\n\u0026mdash; a-know (@a_know) 2018年12月1日\r\r正直なところ技術的なポイントは何もないのですが，せっかくなのでPixelaの利用事例として記事化してみました．やったことは以下だけです．\n PixelaのWebhookとIFTTTのInstapaper連携を用いることで下記を実現し，\u0026ldquo;あとで読む\u0026quot;を可視化  Instapaperに新たに記事が追加されたら，DecrementのWebhookを叩きpixelを茶色化 Instapaperに保存した記事が(読み終わって)アーカイブされたら，IncrementのWebhookを叩きpixelを緑化    動機：溜まっていく一方の\u0026quot;あとで読む\u0026rdquo;  気になった記事があると，あとでちゃんと読もうとInstapaperやはてブなどのサービスに記事を放り込んでおくのはよくあるかなと しかしこの\u0026quot;あとで読む\u0026quot;は，積読や積みゲーよろしく溜まっていく一方になりがち これに対し，下記の点を可視化できれば溜め込まないモチベになるかも？  どれくらい記事をあとで読むつもりで放り込んでいるか (溜め込み度合い) どれくらいあとで読むことにした記事を読んでいるか (消化度合い)    解決(?)：Pixelaでの可視化 以下のIFTTT Appletを作成し，\u0026ldquo;あとで読む\u0026quot;記事の数を可視化\n Instapaper (If New item saved) -\u0026gt; Webhooks (then Make a web request)  Instapaper部分は，事前にアカウント連携しておき，既存のアクションを選択するのみ Webhooksでは，PixelaのDecrement Webhookを実行  記事が増えるのはネガティブ方向なのでDecrement = 茶色化     Instapaper (If New archived item) -\u0026gt; Webhooks (then Make a web request)  Instapaper部分は，事前にアカウント連携しておき，既存のアクションを選択するのみ Webhooksでは，PixelaのIncrement Webhookを実行  記事が減るのはポジティブ方向なのでIncrement = 緑化      Webhooksの部分の詳細  Pixela API Documentを参考に，Increment/DecrementのWebhookを作っておく IFTTT上では，\u0026ldquo;that\u0026quot;側で\u0026quot;Webhooks\u0026quot;を選択し，下記パラメタを設定  URL: https://pixe.la/v1/users/\u0026lt;your-user-id\u0026gt;/webhooks/\u0026lt;your-webhook-hash\u0026gt; Method: POST ContentType: application/json Body: blankでOK    お試し中：記事数の累計値の草化  Pixela自体は日々の数値を記録するものだが，前日の数値を引き継げば累計値の可視化も可能ではと思い立つ (もはや草で可視化しなくてもいいのですが) そこで，1日1回，前日の数値を当日に記録する処理をサーバーレスで実装  AWS Lambda関数の実装：cumulated-pixela   あとは記事が追加されたらIncrement，アーカイブされたらDecrementするようIFTTT Appletを設定 現在お試し運用中，下記のようなイメージに→グラフから草を消すという逆モチベに  ","ref":"/blog/posts/2018_12_02/"},{"title":"Elastic Beanstalkで作成されたS3 バケットが削除できないときの対応","date":"","description":"","body":"現象  Elastic Beanstalkを用いるとソースコードなどを格納するS3バケットが作成される アプリ自体を削除したあともバケットが残っている場合，S3のコンソールから削除しようとしても削除できない場合あり  原因  自動でバケットポリシーが設定されており，明示的に削除が拒否されている  対策  バケットのコンソールで\u0026quot;アクセス権限\u0026quot;→\u0026quot;バケットポリシー\u0026quot;を選択し，右上の\u0026quot;削除\u0026quot;でポリシーを削除 その後，バケット一覧に戻り，再びバケット削除を実行すれば削除されるはず  ","ref":"/blog/posts/2018_11_29/"},{"title":"serverless framworkで画像認識して関係する映画を推薦するSlack Botを作ったまとめ (No Server November Challenge)","date":"","description":"","body":"  serverless frameworkを開発しているServerless, Inc.の企画で，No Server Novemberが開催中\n  11月中に毎週課題が出される\n Challenges that are designed to help experienced users level up, and brand new users get started    githubリポジトリのリンクを#noServerNovemberをつぶやくとなにか(official Serverless swag)もらえる?\n  Nov 12の課題であるAnimalBotとNov 19の課題であるSlack botを組み合わせて開発してみたので内容の紹介\n Nov 12 AnimalBot: 画像URLをメンションすると写っている動物を返信するTwitter Botを作る課題 Nov 19 Slack bot: /actionとすると80年台アクション映画をランダムに教えてくれるSlack Botを作る課題    作ったもの  Slack上でBotに画像URLをメンションすると，写っている内容と，関連する映画を教えてくれるシステム  画像認識にはAmazon Rekognitionを利用 映画情報はThe Movie DatabaseからAPI経由で取得    結果  猫の画像を送ると，猫が写っていることと，関連映画として魔女の宅急便を教えてくれた  環境  MacOS Mojave Python 3.6.5 Serverless Framework 1.32.0  つまづきメモ  [Lambdaプロキシ] POSTリクエスト本体はevent.bodyの中にStringではいる(JSONじゃない！)ので，event.body配下を再度JSONとして読み込み直す必要あり  def main(event, context): body_str = event[\u0026#39;body\u0026#39;] ## これだとただの文字列 body_json = json.loads(event[\u0026#39;body\u0026#39;]) ## これでJSONとして扱える ...  Lambda + Pythonで画像処理ライブラリPillow(PIL)を使う場合，ローカルがMac,実行環境はLinuxベースのため，ローカルでライブラリを同梱しても動作しない  よって，serverless-python-requirementsを用いてライブラリ管理をする (Amazon LinuxのDockerイメージを利用) 関連する設定は以下    ... provider: name: aws runtime: python3.6 ... plugins: - serverless-python-requirements custom: pythonRequirements: dockerizePip: true ...   Lambda上で一時的にファイルを作成したい場合は必ず/tmp配下を指定する\n 今回はURLで指定された画像を一旦Lambdaローカルに保存し処理 その際，保存先は/tmp以外は不可 (権限なし)  OSError: [Errno 30] Read-only file system      Slack APIでメッセージをPostする際，画像などの付属情報を設定可能なattachmentsは，JSON内でStringとして格納しなければならない\n つまり，attachmentsの値はjson.dumsする必要あり    # これはOK data_correct = { ... \u0026#34;attachments\u0026#34;: json.dumps([ { \u0026#34;title\u0026#34;: movie_info[\u0026#39;title\u0026#39;], \u0026#34;image_url\u0026#34;: movie_img_url } ]) } # これは駄目 data_err = { .... \u0026#34;attachments\u0026#34;: [ { \u0026#34;title\u0026#34;: movie_info[\u0026#39;title\u0026#39;], \u0026#34;image_url\u0026#34;: movie_img_url } ] } 開発詳細 つくったものはGitHub - jagijagijag1/animal-recog-slack-botで公開\n serverless.yml, handler.pyを編集し，ひとまずBot処理を作成 Slack，Movie DBで作業し，API Token取得 serverless.ymlを再度編集し，Lambda環境変数にAPI Token情報  1. Serverless framework + Pythonで開始 $ sls create -t aws-python3 -p \u0026lt;project-name\u0026gt; serverless.ymlの修正  環境変数部分は後で埋めるのでひとまずブランク  service: animal-recog-slack-bot provider: name: aws runtime: python3.6 region: ap-northeast-1 iamRoleStatements: - Effect: \u0026#34;Allow\u0026#34; Action: - \u0026#34;rekognition:DetectLabels\u0026#34; Resource: \u0026#34;*\u0026#34; plugins: - serverless-python-requirements custom: pythonRequirements: dockerizePip: true functions: hello: handler: handler.main events: - http: path: / method: POST environment: OAUTH_TOKEN: \u0026#39;\u0026#39; BOT_TOKEN: \u0026#39;\u0026#39; MOVIE_DB_API_TOKEN: \u0026#39;\u0026#39; timeout: 20 関数本体を作成   やや長いのでソースコードはこちら参照\n  画像はURLで受付，一旦Lambda関数ローカルに保存し，RekognitionにByteとして受け渡す\n  Rekognitionではかなり一般的な単語(e.g. Animal, Pet)をラベル候補の上位に出してくるため，暫定処理としてNGワード(ignore_word)を設定し回避\n  関連映画を取得する処理の概要は以下\n Rekognitionのラベル検出結果から一語を選択 選択した後がMovie DBでキーワード登録されているか確認(API: /search/keyword)し，登録ありの場合はID取得 (なしの場合は終了) 獲得したキーワードIDを用いて映画検索(API: /discover/movie?with_keyword=) 検索結果からランダムに選択した映画をSlackに返す    デプロイ $ sls plugin install -n serverless-python-requirements $ docker pull lambci``/lambda``:build-python3.6 $ sls deploy -v 2. Slack，Movie DBで作業し，API Token取得 Slack app準備  Building Slack apps | SlackでCreate その後の画面で左側メニューの\u0026quot;Bot User\u0026quot;を選び，Bot Userを追加 左メニュー\u0026quot;Event Subscriptions\u0026quot;からイベントを有効にし，\u0026ldquo;Request URL\u0026quot;にAPI GatewayのURLを指定し，challengeが帰ってくることを確認 (Lambdaコードに処理を埋め込み済) challenge成功後，\u0026ldquo;Subscribe to Bot Events\u0026quot;で\u0026quot;app_mention\u0026quot;イベントを追加 左メニュー\u0026quot;Installed App\u0026quot;からアプリをWorkspaceにインストール 左メニュ「OAuth \u0026amp; Permissions」にてWorkspaceにAppをInstallすると\u0026quot;OAuth Access Token\u0026quot;と\u0026quot;Bot User OAuth Access Token\u0026quot;が発行される (あとでserverless.ymlに追記)  Movie DB準備  登録し，Settingから申請可能  参考：API Docs   申請完了後もSetting-\u0026gt;APIでAPIキーを確認可能  本アプリではv3 auth利用    3. serverless.ymlを再度編集し，Lambda環境変数にAPI Token情報を追記  OAUTH_TOKEN: SlackのOAuth Access Token BOT_TOKEN: SlackのBot User OAuth Access Token MOVIE_DB_API_TOKEN: The Movie DatabaseのAPIキー (v3 auth)  ... functions: hello: ... environment: OAUTH_TOKEN: \u0026lt;your-token\u0026gt; BOT_TOKEN: \u0026lt;your-token\u0026gt; MOVIE_DB_API_TOKEN: \u0026lt;your-token\u0026gt; ...  参考  slack bot開発  AWS初心者でもわかる！ ブラウザ上で完結！ AWS+Slack Event APIを使ったSlackボット超入門 - Qiita    ","ref":"/blog/posts/2018_11_24/"},{"title":"Togglの記録をServerless + Pixelaで草化","date":"","description":"","body":" 作業時間などの時間管理ツールとしてTogglがある  いつ，どの作業をしたかを記録 各作業をプロジェクトやタグで分類可能 Toggl Reportsで可視化も提供されており，特定の作業をどれくらい継続しているか，どのくらい時間をかけているかを見れる でもとりあえず草化したい！   ToggleはAPIを提供しているので比較的用意にデータ抽出可能  画像認識とかいらない！    作ったもの  1日1回，前日に特定プロジェクトにかけた時間をTogglから抽出し，Pixelaに記録  結果  自分の勉強時間を草化できた  環境  MacOS Mojave Go 1.11.1 Serverless Framework 1.32.0  つまづきメモ  しょぼい内容だが備忘録として  Lambdaにて時間を扱う場合の注意  CloudWatch Eventsをcron式で時間指定する場合，UTCで指定すること  e.g. JSTで毎日午前1時に実行したい→UTCで午後4時(-9時間)を指定する cron( 0 16 * * ? * )   Lambda関数で日時を取得する場合(e.g. Goでのtime.Now())，標準ではUTCで取得する 日本時間を使いたい場合はLambda関数の環境変数でタイムゾーンを指定すること  e.g. 変数TZ, 値Asia/Tokyo    Toggl APIの使い方  TogglのAPIを利用したい場合，リクエストにAPIトークンを含める  APIトークンはProfileから取得可能: https://support.toggl.com/my-profile/   今回は特定期間の記録を全取得し，特定プロジェクトの記録のみ加算していき合計時間を取得 特定期間の記録を取得するAPIは以下  GET https://www.toggl.com/api/v8/time_entries?start_date=XXX\u0026amp;end_date=XXX 日時はISO 8601形式   今回はGoのwrapperであるdougEfresh/gtogglを利用  READMEの記載内容だとうまく行かず    import \u0026#34;github.com/dougEfresh/gtoggl\u0026#34; import \u0026#34;github.com/dougEfresh/gtoggl-api/gtproject\u0026#34; func main() { // HTTP client作成  thc, err := gthttp.NewClient(\u0026#34;your-api-token\u0026#34;) ... // Togglの記録(time entry)取得用クライアント作成  tec := gttimeentry.NewClient(thc) // 特定期間の記録を取得 \tentries, eerr := tec.GetRange(start_date, end_date) } 開発詳細  作ったものはGitHub - jagijagijag1/toggl2pixelaで公開  Serverless framework + Goで開始  $GOHOME/src配下で作業  $ serverless create -t aws-go-dep -p \u0026lt;project-name\u0026gt;  東京リージョンにデプロイしたいのでserverless.ymlにregionを追記  provider: name: aws runtime: go1.x region: ap-northeast-1  以下でひとまずデプロイテスト可能  $ cd \u0026lt;project-name\u0026gt; $ make $ sls deploy 新規関数を作成  関数を新規作成  自動生成された関数は不要なので削除 toggl2pixelaフォルダを作成し，main.goを作成 Makefileのbuild:に以下を追記    env GOOS=linux go build -ldflags=\u0026quot;-s -w\u0026quot; -o bin/toggl2pixela toggl2pixela/main.go\rserverless.ymlの修正  serverless.ymlの主な修正・追記点は以下  新規作成した関数定義の追記 （+自動生成された関数定義の削除) events下にschecule: ***を書くことで定期実行を定義 (下記では毎日午前1時に実行，上述の通りcron式の時間はUTC指定なので注意) Lambda関数でJSTで日時取得したいので，環境変数TZ, 値Asia/Tokyoを指定 Lambda関数の環境変数(environment)にTogglのAPIキー/対象プロジェクトID，Pixelaのユーザ/トークン/グラフ情報を与える    service: toggl2pixela frameworkVersion: \u0026#34;\u0026gt;=1.28.0 \u0026lt;2.0.0\u0026#34; provider: name: aws runtime: go1.x region: ap-northeast-1 package: exclude: - ./** include: - ./bin/** functions: toggl2pixela: handler: bin/toggl2pixela events: - schedule: cron(0 16 * * ? *) # you need to fill the followings with your own environment: TZ: Asia/Tokyo TOGGL_API_TOKEN: \u0026lt;your-api-token\u0026gt; TOGGL_PROJECT_ID: \u0026lt;target-project-id\u0026gt;  PIXELA_USER: \u0026lt;user-id\u0026gt; PIXELA_TOKEN: \u0026lt;your-token\u0026gt; PIXELA_GRAPH: \u0026lt;your-graph-id-1\u0026gt; timeout: 10 関数本体を作成  素直に実装しただけなので，特記事項なし…  データ元のToggl，データ投入先のPixelaの情報は環境変数(TOGGL_API_TOKEN, TOGGL_PROJECT_ID, PIXELA_USER, PIXELA_TOKEN, PIXELA_GRAPH)から取得 GoでのToggl操作にはdougEfresh/gtogglを利用  利用方法は上述   GoでのPixela操作にはgainings/pixela-go-clientを利用    package main import ( \u0026#34;context\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/aws/aws-lambda-go/lambda\u0026#34; \u0026#34;github.com/dougEfresh/gtoggl-api/gthttp\u0026#34; \u0026#34;github.com/dougEfresh/gtoggl-api/gttimentry\u0026#34; pixela \u0026#34;github.com/gainings/pixela-go-client\u0026#34; ) // Handler is our lambda handler invoked by the `lambda.Start` function call func Handler(ctx context.Context) error { // extract env var \tapiToken := os.Getenv(\u0026#34;TOGGL_API_TOKEN\u0026#34;) pjID, _ := strconv.ParseUint(os.Getenv(\u0026#34;TOGGL_PROJECT_ID\u0026#34;), 10, 64) user := os.Getenv(\u0026#34;PIXELA_USER\u0026#34;) token := os.Getenv(\u0026#34;PIXELA_TOKEN\u0026#34;) graph := os.Getenv(\u0026#34;PIXELA_GRAPH\u0026#34;) // extract data from toggl \tdate, quantity := getDateAndTimeFromToggl(apiToken, pjID) if date == \u0026#34;-1\u0026#34; || quantity == \u0026#34;-1\u0026#34; { return errors.New(\u0026#34;Error in accessing toggl\u0026#34;) } fmt.Printf(\u0026#34;date: %s, quantity: %s\\n\u0026#34;, date, quantity) // record pixel \tperr := recordPixel(user, token, graph, date, quantity) if perr != nil { return errors.New(\u0026#34;Error in accessing pixela\u0026#34;) } return nil } func getDateAndTimeFromToggl(apiToken string, pjID uint64) (string, string) { // create toggl client \tthc, err := gthttp.NewClient(apiToken) if err != nil { fmt.Println(err) return \u0026#34;-1\u0026#34;, \u0026#34;-1\u0026#34; } // set time range to be analyzed \ty := time.Now().AddDate(0, 0, -1) s := time.Date(y.Year(), y.Month(), y.Day(), 0, 0, 0, 0, time.Local) e := time.Date(y.Year(), y.Month(), y.Day(), 23, 59, 59, 0, time.Local) date := y.Format(\u0026#34;20060102\u0026#34;) // get time entries \ttotal := int64(0) tec := gttimeentry.NewClient(thc) entries, eerr := tec.GetRange(s, e) if eerr != nil { fmt.Println(eerr) return \u0026#34;-1\u0026#34;, \u0026#34;-1\u0026#34; } // sum durations with project pjID \tfor _, e := range entries { if e.Pid == pjID { total += e.Duration } } totalMin := float64(total) / 60 quantity := strconv.FormatFloat(totalMin, \u0026#39;f\u0026#39;, 4, 64) return date, quantity } func recordPixel(user, token, graph, date, quantity string) error { c := pixela.NewClient(user, token) // try to record \terr := c.RegisterPixel(graph, date, quantity) if err == nil { fmt.Println(\u0026#34;recorded\u0026#34;) return err } // if fail, try to update \terr = c.UpdatePixelQuantity(graph, date, quantity) if err == nil { fmt.Println(\u0026#34;updated\u0026#34;) } return err } func main() { lambda.Start(Handler) } ","ref":"/blog/posts/2018_11_10/"},{"title":"CAV 2018でのAWS招待講演のまとめ","date":"","description":"","body":"Formal Reasoning About the Security of Amazon Web Services 形式手法に関するトップカンファレンスであるCAV 2018にて，AWSから講演(Invited Paperの発表)がありました．\nそこでの発表からAWSは形式手法にかなり力を入れている印象を受け，割と重要な内容かなと思い，単なる箇条書きですが抜粋・まとめてみました． 月並みですがAWSも中の人達もまじすごい．\n著者(発表者)/所属機関 Byron Cook (Amazon Web Services, University College London)\n出典 FLoC 2018 (CAV 2018)\n FLoC Plenary Lecture (CAV 2018 Invited Paper)  AWSでの形式手法の活用について Open Accessのため↓で閲覧可能  Formal Reasoning About the Security of Amazon Web Services | SpringerLink   講演の映像も↓から視聴可能  Formal Reasoning about the Security of Amazon Web Services | University of Oxford Podcasts - Audio and Video Lectures      内容  AWSでは分散アルゴリズムの設計に形式手法(TLA+)を使用 (2014) その後も継続的に形式手法を取り入れいているようで，本論文では特にセキュリティへの形式手法適用事例を紹介  Security of the Cloud: Where Formal Reasoning Fits In  AWS内部の開発，特にセキュリティレビューで定理証明やモデル検査(symbolic model checking)の利用が増えている 2017年だけでも下記の事例にて定理証明やモデル検査を適用  s2n (TLS/SSL実装)の検証  ちなみにこの内容の論文が同会議にて発表されている Continuous Formal Verification of Amazon s2n | SpringerLink   ハイパーバイザ，ブートローダ，BIOS，ファームウェアの検証  こっちも同会議で発表あり Model Checking Boot Code from AWS Data Centers | SpringerLink   ガーベッジコレクタ ネットワーク設計   OSSを活用しつつ使う上で生じた変更をフィードバックしており，例えば下記を利用+貢献  CBMC: C/C++向けのbounded model checker SAW: CやJabaでの特定性質の検証 SMACK: Cプログラムに対するアサーション検証   s2nなど一部プロジェクトでは形式検証ツールをCI/CDに組み込み，継続的検証を実施 SMT-basedのツールで設定ミス防止を図っている 形式手法の利用はコードを書く前から始まっている＝プロトコルやアルゴリズムの設計段階から利用  Securing Customers in the Cloud  AWS利用者側に対しても形式手法の適用が始まっている  例えば，S3の公開設定ミスを警告する機能をSMTソルバを用いて実現  おそらく↓の話 How AWS uses automated reasoning to help you achieve security at scale | AWS Security Blog   AWS Macieでも同様のツールを利用 複雑なネットワーク設定時の到達性(おそらくルーティングや通信可否)をdatalogを用いて検証    その他  他社事例(文献)として以下に言及 (抜粋)  IBM, Google @ Dagstuhl Seminar 2013 Microsoft @ SOSP 2015 分散システムの検証 Facebook @ LICS 2018 codebaseの継続的検証    感想  TLA+の適用に始まり，AWSは形式手法の適用に対し継続的に力を入れいている印象 特に今回は，形式検証のトップカンファレンスであるCAVにて2本の論文採択+Invited talkをしており抜きん出ている こういった会議でプレゼンスを上げることで，AWS利用時の安心度・信頼感が高まる素晴らしい取り組み これだけセキュリティチームで形式手法が利用される/開発者もTLA+などを使えるところを見るに，中の人がちゃんとComputer Scienceの素養を持っていて優秀な模様  ","ref":"/blog/posts/2018_11_07/"},{"title":"Garmin connectのストレス測定結果をPixela + Serverlessで草化","date":"","description":"","body":"  Garmin connectでは心拍数の計測をもとにストレスを数値化してくれる\n  アプリ内では，一覧でみたいときに折れ線グラフしかない + 最大4週間分しか見れない\n  別の可視化方法として草化してみたい\n  作ったもの   Garmin connectの画面キャプチャをS3にアップロードすると，日付とストレス値をPixelaに記録するシステム\n  2018/11/17 追記： 下記を用いればiOSでスクリーンショットを取るだけでPixelaに記録できます． (iOS→Dropbox by IFTTT + Dropbox→S3 by Zapier）\n Add your latest iPhone screenshots to a Dropbox folder Amazon S3 + Dropbox Integrations  結果：いい感じに草化できた気がする   直近のストレスが高い，日曜は比較的ストレスが少ない\n  なるべく色がつかない(薄くなる)ようにしたいという逆モチベ\n  環境  MacOS Mojave Go 1.11.1 Serverless Framework 1.32.0 iPhone 7(iOS 12.01) + Garmin Connect 4.12.0.14  Pixelaへのデータ投入方法の検討  iOS ヘルスケア  Garmin connectのアプリから連携されない   Garminの公式API (2種類)  Garmin Health API  全データ取得可能かつ無料だが，企業向けのため利用不可   Garmin Connect API  個人利用可だが，フィットネスデータのみが対象かつ有料($5,000)     アプリ画面から抽出   アプリ画面を都度キャプチャする必要あり\n  APIがなくても，直に情報を抽出可能\n  Amazon Rekognitionで試した感じ，行けそう\n    開発詳細  作ったものはjagijagijag1/GarminStress2Pixelaで公開  Serverless framework + Goで開始  $GOHOME/src配下で作業  $ serverless create -t aws-go-dep -p \u0026lt;project-name\u0026gt;  東京リージョンにデプロイしたいのでserverless.ymlにregionを追記  provider: name: aws runtime: go1.x region: ap-northeast-1  以下でひとまずデプロイテスト可能  $ cd \u0026lt;project-name\u0026gt; $ make $ sls deploy 新規関数を作成  関数を新規作成  自動生成された関数は不要なので削除 garmin-stress2pixelaフォルダを作成し，main.goを作成 Makefileのbuild:に以下を追記    env GOOS=linux go build -ldflags=\u0026quot;-s -w\u0026quot; -o bin/garmin-stress2pixela garmin-stress2pixela/main.go\rserverless.ymlの修正  serverless.ymlの主な修正・追記点は以下  IAM RoleにRekognitionのDetectText実行許可と，画像を投入するS3バケットへのアクセス許可を追記 新規作成した関数定義の追記 （+自動生成された関数定義の削除)  events下のs3: \u0026lt;bucket-name\u0026gt;は存在しないバケット名とすること (sls deployで新規作成されるため) Lambda関数の環境変数(environment)にPixelaのユーザ/トークン/グラフ情報を与える      service: GarminStress2Pixela frameworkVersion: \u0026#34;\u0026gt;=1.28.0 \u0026lt;2.0.0\u0026#34; provider: name: aws runtime: go1.x region: ap-northeast-1 # you can add statements to the Lambda function\u0026#39;s IAM Role here iamRoleStatements: - Effect: \u0026#34;Allow\u0026#34; Action: - \u0026#34;rekognition:DetectText\u0026#34; Resource: \u0026#34;*\u0026#34; - Effect: \u0026#34;Allow\u0026#34; Action: - \u0026#34;s3:GetObject\u0026#34; Resource: [ \u0026#34;arn:aws:s3:::pixela-datasource-stress-img-bucket\u0026#34;, \u0026#34;arn:aws:s3:::pixela-datasource-stress-img-bucket/*\u0026#34; ] package: exclude: - ./** include: - ./bin/** functions: garmin-stress2pixela: handler: bin/garmin-stress2pixela events: - s3: \u0026lt;bucket-name\u0026gt; # you need to fill the followings with your own environment: PIXELA_USER: \u0026lt;user-id\u0026gt; PIXELA_TOKEN: \u0026lt;your-token\u0026gt; PIXELA_GRAPH: \u0026lt;your-graph-id-1\u0026gt; timeout: 10 関数本体を作成  作っている最中の気づき，ポイントは以下  GoでのAWSイベントは以下にサンプルがあり，これを参照しHandlerの引数，入力情報処理を実装  aws-lambda-go/events at master aws/aws-lambda-go GitHub   InvalidS3ObjectException に当たった  InvalidS3ObjectException: Unable to get object metadata from S3. Check object key, region and/or access permissions. S3 Objectへのアクセス権限をLambad関数にも付与すること (上記yamlにて済) S3バケットのリージョンと，Rekognitionのリージョンを同じにすること  Rekognitionは同一リージョンのバケット内オブジェクトにしかアクセスできない模様     [作り込み・汎用性低] 日付・ストレス値は，事前に画像内での想定位置を与え，Rekognition.DetectTextの結果のうち，想定位置の最も近傍のテキストを選択  想定位置(assumedDatePoint, assumedQuantityPoint)はiPhone 7(iOS 12.01)，Garmin Connect 4.12.0.14にて実験的に抽出   データ投入先のPixelaの情報は環境変数(PIXELA_USER, PIXELA_TOKEN, PIXELA_GRAPH)から取得 GoでのPixela操作にはgainings/pixela-go-clientを利用    package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; \u0026#34;os\u0026#34; \u0026#34;regexp\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/aws/aws-lambda-go/events\u0026#34; \u0026#34;github.com/aws/aws-lambda-go/lambda\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/aws/session\u0026#34; \u0026#34;github.com/aws/aws-sdk-go/service/rekognition\u0026#34; pixela \u0026#34;github.com/gainings/pixela-go-client\u0026#34; ) // Point is left \u0026amp; top positions of bounding box in the Rekognition result type Point struct { Left float64 Top float64 } // !! fixed number from experiment (maybe require to change your env) !! var assumedDatePoint = Point{Left: 0.393, Top: 0.111} var assumedQuantityPoint = Point{Left: 0.268, Top: 0.282} // Handler is our lambda handler invoked by the `lambda.Start` function call func Handler(ctx context.Context, s3Event events.S3Event) error { // for each s3 object \tfor _, record := range s3Event.Records { // extract s3 object info \tbucket, key := getS3ObjectFromRecord(record) fmt.Printf(\u0026#34;[%s] Bucket = %s, Key = %s \\n\u0026#34;, record.EventSource, bucket, key) // execute text detection of Rekognition \tres, rekerr := exeRekognitionDetectText(bucket, key) if rekerr != nil { fmt.Println(\u0026#34;Error\u0026#34;) fmt.Println(rekerr.Error()) } // extract date \u0026amp; quantity from the above result \tdate, quantity := getValueFromRekognitionResult(res.TextDetections) fmt.Printf(\u0026#34;data: %s, quantity: %s\\n\u0026#34;, date, quantity) // record pixel \tperr := recordPixel(date, quantity) fmt.Println(perr) } return nil } func getS3ObjectFromRecord(record events.S3EventRecord) (string, string) { s := record.S3 bucket := s.Bucket.Name rep := regexp.MustCompile(`[+]`) key := rep.ReplaceAllString(s.Object.Key, \u0026#34; \u0026#34;) return bucket, key } func exeRekognitionDetectText(bucket, key string) (*rekognition.DetectTextOutput, error) { // create Rekognition client \tsess := session.Must(session.NewSession()) rc := rekognition.New(sess, aws.NewConfig().WithRegion(\u0026#34;ap-northeast-1\u0026#34;)) // set params \tparams := \u0026amp;rekognition.DetectTextInput{ Image: \u0026amp;rekognition.Image{ S3Object: \u0026amp;rekognition.S3Object{ Bucket: aws.String(bucket), Name: aws.String(key), }, }, } fmt.Printf(\u0026#34;params: %s\u0026#34;, params) // execute DetectText \treturn rc.DetectText(params) } func getValueFromRekognitionResult(results []*rekognition.TextDetection) (string, string) { dateHypot, quantityHypot := math.MaxFloat64, math.MaxFloat64 date, quantity := \u0026#34;\u0026#34;, \u0026#34;\u0026#34; // for each detected text \tfor _, td := range results { left, top := *td.Geometry.BoundingBox.Left, *td.Geometry.BoundingBox.Top // calc hypot with assumed date pos \u0026amp; update value \ttmpDHypot := math.Hypot(math.Abs(left-assumedDatePoint.Left), math.Abs(top-assumedDatePoint.Top)) if tmpDHypot \u0026lt; dateHypot { // if td is most-likely-result (nearest to the assumed point), keep the result (with removing \u0026#34;/\u0026#34;) \tdateHypot, date = tmpDHypot, strings.Replace(*td.DetectedText, \u0026#34;/\u0026#34;, \u0026#34;\u0026#34;, -1) } // calc hypot with assumed quantity pos \u0026amp; update value \ttmpQHypot := math.Hypot(math.Abs(left-assumedQuantityPoint.Left), math.Abs(top-assumedQuantityPoint.Top)) if tmpQHypot \u0026lt; quantityHypot { // if td is most-likely-result (nearest to the assumed point), keep the result \tquantityHypot, quantity = tmpQHypot, *td.DetectedText } } return date, quantity } func recordPixel(date, quantity string) error { user := os.Getenv(\u0026#34;PIXELA_USER\u0026#34;) token := os.Getenv(\u0026#34;PIXELA_TOKEN\u0026#34;) graph := os.Getenv(\u0026#34;PIXELA_GRAPH\u0026#34;) c := pixela.NewClient(user, token) // try to record \terr := c.RegisterPixel(graph, date, quantity) if err == nil { fmt.Println(\u0026#34;recorded\u0026#34;) return err } // if fail, try to update \terr = c.UpdatePixelQuantity(graph, date, quantity) if err == nil { fmt.Println(\u0026#34;updated\u0026#34;) } return err } func main() { lambda.Start(Handler) } ","ref":"/blog/posts/2018_10_28/"}]